# CS530 Matthew Turi - ID: 822202323, Hector Nevarez - ID: 823115001

In order to construct the dissasembler, we followed the steps below:
  1. Parse input files
  2. Sort instructions from the text records
  3. Build the LOC column from instructions, symbols, and literals
  4. Build the labels column if a symbol is being used/defined at the given location
  5. Set the mnemonics for each instruction using the LOC previously calculated
  6. Calculate the target addresses and build the third column of the listing file
  7. Write results to listing file 
  
  
  
### Parse input files:
The first step was to take the given input files are parse them based off the content we needed. Starting with the object file, this document was parsed based on the record. For header records, the information was stored inside a string that allowed us to mainly retrieve the name of the program. The text records were stored in a vector with each entire text record being stored in an individual index. The modification record was stored in a vector with each modifcation record making up a different index of the vector, and the end record was stored in a string. After the object file was parsed, we moved on to the symbol table. For this, we stored any symbols in a vector. Once we parsed through all the symbols, we then stored all the literals in a seperate vector.

### Sort instructions from the text records:
The first major step of the dissasembler was to parse the text records. We needed to extract a few key pieces of information in this step; what was the format of each instruction, and where were the literals. The first step was to locate where the literals were. Before each iteration, the code checks whether it is encountering a literal. If so, the literal, in hex format, is appended to a vector that holds all of the instructions. After, we needed to find the type of instruction we were dealing with. First, we checked if we were dealing with a format 2. To do this, we parsed the first byte of the text record, converted it to binary, dropped the two trailing bits and appended zeros. After this we referenced the lookup table with the opcodes, formats, and mnemonic. If it was a format two, we parsed the remaining byte, put both together in binary, and appended it to a vector that held all of the instructions. Lastly if the instruction was neither a literal or format 2 instruction, we grabbed 2 bytes from the text record and checked the e bit. Based on this we added the appropriate amount of bytes, 1 more for format 3 and 2 more bytes for format 4, and appended the binary values to a vector that held all the instructions. This process was repeated for every bit in the text record.

### Build the LOC column from instructions, symbols, and literals:
The next step of the dissasembler was to create the location counter for each line of the program. To do so, we needed to use the instructions calculated in the previous step, the header record, and the symbols and literals parsed from the symtab. The function first stores the start value for the program and then loops through each instruction and first checks if there is a literal defined instead of just holding binary bits. If there is, the first literal is parsed from the literals vector, and its length / 2 is added to the previous value stored in the loc vector. If this check yields that there is not a literal, it instead determines the format of the given instruction by parsing the first 6 bits, adding 00, converting to hex, and then using the lookup table that stores each opcode, format, and mnemonic. If the mnemonic can be format 3/4, it checks the length of the instruction and if it is larger than 24 bits, uses format 4. Otherwise, it uses format 3. These values are added to the previous loc and pushed into the vector. Once each instruction has been checked, the symbols are added to the bottom of the locctr by checking the given addresses.

### Build the labels column if a symbol is being used/defined at the given location:
Next, the labels in the second column fo the listing file needed to be generated. To do so, we needed the loc vector that was just generated, the symbols vecotr, and the header record for the program name. First, the program name is stored as the first value. Then, the function loops through each value in the loc vector and each symbol in the symbols vector. This checks to see if any symbol address in the symbols vector matches that of the locctr. If they ,match, the symbol name is parsed and pushed into the new labels vecotr. Otherwise, a blank string is pushed to add a new line when necessary. 

### Set the mnemonics for each instruction using the LOC previously calculated:
Next, the mnemonics for each instruction need to be generated. In order to do so, we needed the vectors storing the instructions and location. First, a blank line is stored due to the program start line. Then, we loop through each instruction, immediately checking if there is a literal at the given lcoation, and if there is a * is pushed onto the vector. If there is not a literal there, the opcode for each instruction is parsed, adding 00 to the end for the 8 bits of opcode. This is converted to hex, and the format and mnemonic are obtained from the lookup table. We then check if it is a format 4 instruction by seeing if the length of the instruction is greater than 24 bits. If format 3, we push back the regular mnemonic, Otherwise, a + is appended to the mnemonic and the resulting string is stored. This loops through each instruction, and once completed, RESW is stored for as many extra entries are stored in the loc vector (excluding the final line). 

### Calculate the target addresses and build the third column of the listing file:
The final column that needs to be generated is the column that stores the operand associated with each mnemonic. To generate this, we needed the instructions, location, literals, symbols, and mnemonics vectors as well as the header record. First, the start directive is stored according to the format of the sample files. Then, we loop through each instruction and mnemonic in order to determine the operand associated with it. In this loop, we first check for some "special cases" which includes all format 2 instructions. These are dealt with accordingly, parsing the bits necessary and pushing back the registers, blank line, or changing the value of X. Next, we check for a literal defined at this location. If there is one, the literal itself is parsed from the vecotr and stored in the new vector. If this is also false, we know that the given instruction is a regular format 3 or 4 instruction. With this, we parse the 6 flag bits and compare them to a chain of predefined cases for these bits. When the correct case is found, the disp/address is parsed, and the TA is calculated accordingly depending on the flag bits. If the menmonic allows for symbols/literals to be used, this TA is then checked against the symbols and literals vectors to see if there is a match. Finally, once we know what the target address is (constant, symbol, literal, etc), we push that address with the correct symbols attached (@, #, ,X, etc) into our vector that will be returned. Once every instruction is dealt with, we add the corresponding symbol sizes by subtracting the next and current hex loc values and dividing by 3 to return the correct size. These values are stored until the last line is reached. To calculate the last symbol size, we must use the program length and subtract the last loc value from that, divide by three, and store the corresponding hex value. 

### Write results to listing file:
Lastly, we wrote the results to the listing file. Since we had stored all information in vectors, we wrote a method that would link these vectors together and appropriately paste the location counter, label, mnemonic, variable, and object code in their respective location. The only other preprocessing that was done in this step was finding where to put the LTORG and BASE if needed. For the LTORG, we just checked when a * was being used to declare a literal and pasted LTORG in the file beforehand. For the BASE, we just looked for the LDB instruction and pasted the BASE right after. Finally it was all written to a listing file stored in a text format. 
